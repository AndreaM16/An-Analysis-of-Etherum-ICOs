\label{Chapter3}

\chapter{A tool for Ethereum analytics}
\section{Architecture of the tool}
\subsection{Parity}
\href{https://www.parity.io/}{Parity} \cite{authors2017ethereum} is an Ethereum client, written from the ground-up for correctness-verifiability, modularisation, low-footprint and high-performance. \newline
To this end it utilises the Rust language, a hybrid imperative/OO/functional language with an emphasis on efficiency. 
\newline
Parity comes with an extensive, in-built Ethereum Wallet and DApp environment. It includes:
\begin{itemize}
    \item Account, address-book and multi-sig management.
    \item Key creation, importing and exporting.
    \item Web3 √êapp browser.
    \item Hardware and electronic cold-wallet support.
    \item Name registry support.
    \item Contract development, deployment and interaction environment.
\end{itemize}
\subsection{Web3J}
\label{web3j}
\href{https://web3j.io/}{Web3J} is a highly modular, reactive, type safe Java and Android library for working with Smart Contracts and integrating with clients (nodes) on the Ethereum network. 
\newline
This allows to work with the Ethereum blockchain, without the additional overhead of having to write an integration code for the platform.
\subsection{JSON-RPC}

\section{Case study: a basic view of the blockchain}
This view contains data about all transactions (and, contract internal transactions) that has been done inside Ethereum blockchain. The fields in this view are the following:
\begin{itemize}
    \item \textit{\textbf{txHash}}: transaction hash;
    \item \textit{\textbf{blockHeight}}: block number of the block that contains this transaction;
    \item \textit{\textbf{txIndex}}: transaction progressive number inside its block;
    \item \textit{\textbf{date}}: the date when block is mined;
    \item \textit{\textbf{from}}: transaction sender (the address of who is transferring money or creating a contract);
    \item \textit{\textbf{to}}: transaction receiver (the address of who is receiving money, this field is empty if this transaction creates a contract);
    \item \textit{\textbf{value}}: how much (in ETH) is transferred;
    \item \textit{\textbf{creates}}: the address of the newly created contract (empty if this transaction does not create a contract);
    \item \textit{\textbf{internalTransactions}}: contains all the internal transactions generated by this transaction, it's a list of objects containing the following fields:
        \subitem \textit{\textbf{parentTxHash}}: hash of the father transaction (the transaction that generates this one);
        \subitem \textit{\textbf{txType}}: internal transaction type (call, suicide, create);
        \subitem \textit{\textbf{from}}: internal transaction sender;
        \subitem \textit{\textbf{to}}: internal transaction receiver;
        \subitem \textit{\textbf{value}}: how much (in ETH) in transferred.
\end{itemize}
\subsection{Querying view in MongoDB}
\subsubsection{Ethereum per day}
This query calculates the total amount of Ether transacted and its mean per day.
\begin{center}
\begin{varwidth}{\linewidth}
\begin{verbatim}
db.myBlockchain.aggregate([
   { $group : {
       _id: {
           year : { $year : "$date" },
           month : { $month : "$date" },
           day : { $dayOfMonth : "$date" },
       },
       sumValues: { $sum: "$value"},
       avgValues: { $avg: "$value"}
   }},
   { $sort : { avgValues : 1, sumValues: 1}}
]);
\end{verbatim}
\end{varwidth}
\end{center}
\subsubsection{Contract creation}
This query search all transactions that create a smart contract. It returns only the created smart contract address. 
\begin{center}
\begin{varwidth}{\linewidth}
\begin{verbatim}
db.myBlockchain.find({
   creates: {$ne: ""}
},{
   _id: 0, creates: 1
});

\end{verbatim}
\end{varwidth}
\end{center}
\section{Case study: Exchange rates}
This view contains data about all transactions, combined with the Ethereum conversion price in USD in that specific day. 
The fields in this view are the following:
\begin{itemize}
    \item \textit{\textbf{txHash}}: transaction hash;
    \item \textit{\textbf{blockHeight}}: block number of the block that contains this transaction;
    \item \textit{\textbf{txIndex}}: transaction progressive number inside its block;
    \item \textit{\textbf{date}}: the date when block is mined;
    \item \textit{\textbf{from}}: transaction sender (the address of who is transferring money or creating a contract);
    \item \textit{\textbf{to}}: transaction receiver (the address of who is receiving money, this field is empty if this transaction creates a contract);
    \item \textit{\textbf{value}}: how much (in ETH) is transferred;
    \item \textit{\textbf{creates}}: the address of the newly created contract (empty if this transaction does not create a contract);
    \item \textit{\textbf{rate}}: Ethereum-USD conversion price.
\end{itemize}
\section{Case study: Levenshtein Distance between contract}
In information theory, Linguistics and computer science, the Levenshtein distance is a string metric for measuring the difference between two sequences.
In order to calculate Levenshtein distance between contracs EVM, first of all we create a view in MongoDB or SQL that contains only useful information retrieved from blockchain.
The useful fields are only two:
\begin{itemize}
    \item \textit{\textbf{contractAddress}}: The contract address inside blockchain (to uniquely identify a contract inside view);
    \item \textit{\textbf{contractCode}}: The contract EVM code
\end{itemize}
The distance calculation is done using this formula:
\begin{center}
$\operatorname{lev}_{a,b}(i,j) = 
\begin{cases}
  \max(i,j) & \text{ if} \min(i,j)=0, \\
  \min \begin{cases}
      \operatorname{lev}_{a,b}(i-1,j) + 1 \\
      \operatorname{lev}_{a,b}(i,j-1) + 1 \\
      \operatorname{lev}_{a,b}(i-1,j-1) + 1_{(a_i \neq b_j)}
   \end{cases} & \text{ otherwise.}
\end{cases}
$
\end{center}


\section{Implementation}
In this section we will explain in details the implementation of the tool, built to retrieve blockchain data and other external data and combine them. \newline
This tool is written in Scala Programming Language and built with Scala Build Tool (SBT). \newline
Scala has been chosen because, since it's compiled in bytecode that runs on Java Virtual Machine (JVM), it can be combined with Java external libraries without any problem. \newline
Thanks to this property, it was possible to use Web3J library to retrieve blockchain data. It is a Java and Android library for working with Smart Contracts and integrating with clients (nodes) on the Ethereum network. \newline
Web3J is the Java version of a Web3 (a Javascript library), which has be explained in \ref{web3j}. In the following paragraph, we explain the created classes.